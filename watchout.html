<!DOCTYPE html>
<html>
  <body>
Watchout!
  </body>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js"></script>

    <script>
    var width = 960,
        height = 500,
        radius = 10;
    var nEnemies = 30;

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var playerData = [{x:480, y:250}];
    var data = _.range(0,nEnemies).map(function(i){return i;});

    var drag = d3.behavior.drag()
        .on("drag", function(d,i) {
            d.x += d3.event.dx
            d.y += d3.event.dy
            d3.select(this).attr("transform", function(d,i){
                return "translate(" + [ d.x,d.y ] + ")"
            })
        });

    // checkCollision will be run at a specific interval (200ms?)
    // passing in a snapshot of the positions of all the enemies at that moment
    // and the player
    var checkCollision() {
      var playerR;
      var playerX;
      var playerY;

      // inside for loop for all the enemies until we hit one
      var enemyR;
      var enemyX;
      var enemyY;

      var sumOfR = playerR + enemyR;


      var separation = Math.sqrt(Math.pow(playerX-enemyX) + Math.pow(playerY-enemyY));
      if (separation < sumOfR) {
        // OOPS!
        // score gets set to zero; checks high score; game over type function to handle these things
      }

    }

    svg.selectAll("circle")
      .data(playerData)
      .enter().append("circle")
      .attr("r", radius)
      .style("fill", "black")
      .attr("class", "player")
      .attr("transform", function(d,i){return ("translate(" + d.x + "," + d.y + ")")})
      .call(drag);

    svg.selectAll("circle")
      .data(playerData.concat(data))
      .enter().append("circle")
      .attr("r", radius)
      .style("fill", "green")
      .attr("class", "enemy");


    svg.selectAll(".enemy")
    //circles are still spawning out of bounds, TODO fix Math.random
       .attr("cx", function(){return Math.random()* ((width-radius*2) - (radius*2))  + (radius*2);})
       .attr("cy", function(){return Math.random()* ((height-radius*2) - (radius*2))  + (radius*2);})


    setInterval(function() {
        svg.selectAll(".enemy")
           .transition()
             .duration(1500)
             .ease("linear")
             .attr("cx", function(){return Math.random()* ((width-radius*2) - (radius*2))  + (radius*2);})
             .attr("cy", function(){return Math.random()* ((height-radius*2) - (radius*2))  + (radius*2);});

    }, 1700);

//function to get snapshot of enemy positions
  var getEnemyPositions = function(){
    var result = [];
    var enemyX = this.attr("cx");
    var enemyY = this.attr("cy");
    result.push([enemyX, enemyY]);
  };

svg.selectAll(".enemy").each(getEnemyPositions);

    </script>



</html>